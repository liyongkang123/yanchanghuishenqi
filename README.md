# yanchanghuishenqi
#include <Adafruit_NeoPixel.h>
#include <avr/pgmspace.h> 
#define PIXELPIN 1
#define SWITCHPIN 0
#define BTNPIN 2
#define IMGCOUNT 3

// Parameter 1 = number of pixels in strip
// Parameter 2 = pin number (most are valid)
// Parameter 3 = pixel type flags, add together as needed:
//   NEO_RGB     Pixels are wired for RGB bitstream
//   NEO_GRB     Pixels are wired for GRB bitstream
//   NEO_KHZ400  400 KHz bitstream (e.g. FLORA pixels)
//   NEO_KHZ800  800 KHz bitstream (e.g. High Density LED strip)

uint8_t const text[] PROGMEM = {
0x08,0x02,0x08,0x01,0x88,0x00,0xC8,0x3F,0xA8,0x00,0x98,0x00,0x8F,0x00,0xE8,0xFF,
0x88,0x00,0x88,0x00,0x88,0x10,0x88,0x20,0x88,0x1F,0x08,0x00,0x08,0x00,0x00,0x00,/*"神",0*/
0x08,0x00,0x08,0x00,0x88,0x00,0x88,0xFC,0x88,0x44,0x88,0x44,0x88,0x44,0xFF,0x44,
0x88,0x44,0x88,0x44,0x88,0x44,0x88,0xFC,0x88,0x00,0x08,0x00,0x08,0x00,0x00,0x00,/*"奇",1*/
0x00,0x00,0x00,0x00,0x00,0x1C,0xFC,0x11,0x04,0x11,0x04,0x11,0x16,0x1F,0x25,0x11,
0x04,0x11,0x24,0x11,0x44,0x5D,0x3C,0x81,0x00,0x41,0x00,0x3F,0x00,0x00,0x00,0x00,/*"魔",2*/
0x20,0x22,0x30,0x67,0xAC,0x22,0x63,0x12,0x30,0x12,0x00,0x40,0x00,0x40,0xFE,0x7F,
0x22,0x42,0x22,0x42,0x22,0x42,0x22,0x42,0xFE,0x7F,0x00,0x40,0x00,0x40,0x00,0x00,/*"幻",3*/

};

uint8_t const text1[] PROGMEM = {
  
0x04,0x01,0x84,0x00,0x44,0x00,0x34,0x1F,0x24,0x09,0x2F,0x09,0x24,0x09,0x24,0x09,
0x24,0x1F,0x2F,0x40,0x24,0x80,0x24,0x40,0xE4,0x3F,0x04,0x00,0x04,0x00,0x00,0x00,/*"摇",0*/
0x40,0x20,0x44,0x10,0x44,0x0C,0x44,0x03,0xC4,0x00,0xFE,0xFF,0x42,0x01,0x43,0x02,
0x42,0x04,0x00,0x00,0xF8,0x0F,0x00,0x40,0x00,0x80,0xFF,0x7F,0x00,0x00,0x00,0x00,/*"摇",1*/
0x00,0x00,0xFE,0xFF,0x02,0x40,0x12,0x48,0x92,0x48,0x92,0x48,0x92,0x48,0xF2,0x4F,
0x92,0x48,0x92,0x4A,0x92,0x4C,0x12,0x48,0x02,0x40,0xFE,0xFF,0x00,0x00,0x00,0x00,/*"棒",2*/
0x10,0x40,0x2C,0x49,0x24,0x49,0x24,0x29,0xA4,0x24,0xA4,0x14,0x65,0x52,0xA6,0x89,
0x24,0x7F,0x24,0x04,0x24,0x0A,0x24,0x11,0xA4,0x10,0x34,0x20,0x0C,0x20,0x00,0x00,/*"!",3*/



};

uint8_t const text2[] PROGMEM = {


0x80,0x40,0x40,0x40,0x30,0x42,0x1E,0x42,0x10,0x42,0x10,0x42,0x10,0x42,0xFF,0x7F,
0x10,0x42,0x10,0x42,0x10,0x42,0x10,0x42,0x10,0x42,0x10,0x40,0x00,0x40,0x00,0x00,/*"欢",0*/
0x02,0x02,0x02,0x81,0xC2,0x40,0x3E,0x21,0x22,0x1A,0x22,0x06,0xE2,0x01,0x02,0x00,
0xFE,0x3F,0x02,0x41,0x82,0x40,0x42,0x40,0x22,0x40,0x12,0x78,0x00,0x00,0x00,0x00,/*"迎",1*/
0x00,0x00,0x00,0x00,0xFC,0x3F,0x00,0x10,0x00,0x08,0x02,0x84,0x04,0x40,0x18,0x20,
0x00,0x10,0x00,0x0C,0x80,0x03,0x7F,0x08,0x00,0x10,0x00,0x20,0x00,0xC0,0x00,0x00,/*"使",2*/
0x00,0x00,0x00,0x00,0x00,0x00,0xFE,0x33,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,/*"用",3*/

};

uint8_t const text3[] PROGMEM = {

0x00,0x00,0x00,0x01,0x00,0x01,0x00,0x01,0xE0,0x0F,0x00,0x01,0x00,0x01,0x00,0x01,/*"+",1*/
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,/*" ",2*/
0x00,0x00,0x00,0x00,0x10,0x20,0x10,0x20,0xF8,0x3F,0x00,0x20,0x00,0x20,0x00,0x00,/*"1",3*/
0x00,0x00,0x70,0x38,0x88,0x20,0x08,0x21,0x08,0x21,0x08,0x22,0x38,0x1C,0x00,0x00,/*"S",4*/
0x00,0x00,0x00,0x01,0x00,0x01,0x00,0x01,0xE0,0x0F,0x00,0x01,0x00,0x01,0x00,0x01,/*"+",1*/
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,/*" ",2*/
0x00,0x00,0x00,0x00,0x10,0x20,0x10,0x20,0xF8,0x3F,0x00,0x20,0x00,0x20,0x00,0x00,/*"1",3*/
0x00,0x00,0x70,0x38,0x88,0x20,0x08,0x21,0x08,0x21,0x08,0x22,0x38,0x1C,0x00,0x00,/*"S",4*/



};

uint8_t const text4[] PROGMEM = {
0x02,0x04,0x02,0x04,0xF2,0xFF,0x92,0x04,0x92,0x04,0x92,0x04,0x92,0x04,0xFE,0x07,
0x92,0x04,0x92,0x04,0x92,0x44,0x92,0x84,0xF2,0x7F,0x02,0x04,0x02,0x04,0x00,0x00,/*"神",0*/
0x20,0x22,0x30,0x67,0xAC,0x22,0x63,0x12,0x20,0x12,0x18,0x12,0x20,0x88,0x24,0x8A,
0xA4,0x4C,0x24,0x29,0x3F,0x18,0xA4,0x0F,0x24,0x18,0xA4,0x28,0x60,0xC8,0x00,0x00,/*"奇",1*/
0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,
0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x00,0x00,/*"魔",2*/
0x24,0x08,0x24,0x06,0xA4,0x01,0xFE,0xFF,0x23,0x01,0x22,0x06,0x00,0x81,0xC0,0x80,
0x38,0x40,0x00,0x40,0xFF,0x27,0x00,0x10,0x08,0x0C,0x10,0x03,0x60,0x00,0x00,0x00,/*"幻",3*/

};
uint8_t const text5[] PROGMEM = {
  
0x04,0x01,0x84,0x00,0x44,0x00,0x34,0x1F,0x24,0x09,0x2F,0x09,0x24,0x09,0x24,0x09,
0x24,0x1F,0x2F,0x40,0x24,0x80,0x24,0x40,0xE4,0x3F,0x04,0x00,0x04,0x00,0x00,0x00,/*"摇",0*/
0x40,0x20,0x44,0x10,0x44,0x0C,0x44,0x03,0xC4,0x00,0xFE,0xFF,0x42,0x01,0x43,0x02,
0x42,0x04,0x00,0x00,0xF8,0x0F,0x00,0x40,0x00,0x80,0xFF,0x7F,0x00,0x00,0x00,0x00,/*"摇",1*/
0x00,0x00,0xFE,0xFF,0x02,0x40,0x12,0x48,0x92,0x48,0x92,0x48,0x92,0x48,0xF2,0x4F,
0x92,0x48,0x92,0x4A,0x92,0x4C,0x12,0x48,0x02,0x40,0xFE,0xFF,0x00,0x00,0x00,0x00,/*"棒",2*/
0x10,0x40,0x2C,0x49,0x24,0x49,0x24,0x29,0xA4,0x24,0xA4,0x14,0x65,0x52,0xA6,0x89,
0x24,0x7F,0x24,0x04,0x24,0x0A,0x24,0x11,0xA4,0x10,0x34,0x20,0x0C,0x20,0x00,0x00,/*"!",3*/



};

uint8_t const text6[] PROGMEM = {


0x80,0x40,0x40,0x40,0x30,0x42,0x1E,0x42,0x10,0x42,0x10,0x42,0x10,0x42,0xFF,0x7F,
0x10,0x42,0x10,0x42,0x10,0x42,0x10,0x42,0x10,0x42,0x10,0x40,0x00,0x40,0x00,0x00,/*"欢",0*/
0x02,0x02,0x02,0x81,0xC2,0x40,0x3E,0x21,0x22,0x1A,0x22,0x06,0xE2,0x01,0x02,0x00,
0xFE,0x3F,0x02,0x41,0x82,0x40,0x42,0x40,0x22,0x40,0x12,0x78,0x00,0x00,0x00,0x00,/*"迎",1*/
0x00,0x00,0x00,0x00,0xFC,0x3F,0x00,0x10,0x00,0x08,0x02,0x84,0x04,0x40,0x18,0x20,
0x00,0x10,0x00,0x0C,0x80,0x03,0x7F,0x08,0x00,0x10,0x00,0x20,0x00,0xC0,0x00,0x00,/*"使",2*/
0x00,0x00,0x00,0x00,0x00,0x00,0xFE,0x33,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,/*"用",3*/

};

uint8_t const text7[] PROGMEM = {

0x00,0x00,0x00,0x01,0x00,0x01,0x00,0x01,0xE0,0x0F,0x00,0x01,0x00,0x01,0x00,0x01,/*"+",1*/
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,/*" ",2*/
0x00,0x00,0x00,0x00,0x10,0x20,0x10,0x20,0xF8,0x3F,0x00,0x20,0x00,0x20,0x00,0x00,/*"1",3*/
0x00,0x00,0x70,0x38,0x88,0x20,0x08,0x21,0x08,0x21,0x08,0x22,0x38,0x1C,0x00,0x00,/*"S",4*/
0x00,0x00,0x00,0x01,0x00,0x01,0x00,0x01,0xE0,0x0F,0x00,0x01,0x00,0x01,0x00,0x01,/*"+",1*/
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,/*" ",2*/
0x00,0x00,0x00,0x00,0x10,0x20,0x10,0x20,0xF8,0x3F,0x00,0x20,0x00,0x20,0x00,0x00,/*"1",3*/
0x00,0x00,0x70,0x38,0x88,0x20,0x08,0x21,0x08,0x21,0x08,0x22,0x38,0x1C,0x00,0x00,/*"S",4*/



};

uint8_t const text8[] PROGMEM = {
0x02,0x04,0x02,0x04,0xF2,0xFF,0x92,0x04,0x92,0x04,0x92,0x04,0x92,0x04,0xFE,0x07,
0x92,0x04,0x92,0x04,0x92,0x44,0x92,0x84,0xF2,0x7F,0x02,0x04,0x02,0x04,0x00,0x00,/*"I",0*/
0x20,0x22,0x30,0x67,0xAC,0x22,0x63,0x12,0x20,0x12,0x18,0x12,0x20,0x88,0x24,0x8A,
0xA4,0x4C,0x24,0x29,0x3F,0x18,0xA4,0x0F,0x24,0x18,0xA4,0x28,0x60,0xC8,0x00,0x00,/*"LOVE",1*/
0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,
0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x00,0x00,/*"YOU",2*/
};

uint8_t tempImage[128];

int flow;
int count;
Adafruit_NeoPixel strip = Adafruit_NeoPixel(16, PIXELPIN, NEO_GRB + NEO_KHZ800);
void setup() {
  strip.begin();
  strip.show(); // Initialize all pixels to 'off'
  pinMode(SWITCHPIN, INPUT);
  pinMode(BTNPIN, INPUT);
  count = 0;
  cpy(text);
}

void loop() {
  // Some example procedures showing how to display to the pixels:
  //colorWipe(strip.Color(255, 0, 0), 50); // Red
  //rainbow(20);
  //rainbowCycle(20);
  if(digitalRead(SWITCHPIN)==HIGH)
  displayImage();

  while(digitalRead(SWITCHPIN)==HIGH){
    if (digitalRead(BTNPIN) == LOW) {
      count++;
      count%=9;
      
    switch(count){
      case 0:
        cpy(text);
        break;
      case 1: 
        cpy(text1);
        break;
      case 2:
        cpy(text2);
        break;
      case 3:
        cpy(text3);
        break;
      case 4:
        cpy(text4);
        break;
      case 5:
        cpy(text5);
        break;
      case 6:
        cpy(text6);
        break;
      case 7:
        cpy(text7);
        break;
      case 8:
        cpy(text8);
        break;
      default: 
        cpy(text);
        break;
    }
    
      while (digitalRead(BTNPIN) == LOW);
    }
  };
}

void displayImage(){
  switch(count){
    case 0:
      showImage();//全彩渐变色（红）
      break;
    case 4: 
      showImage16dots(0x00FF00FF,0x00FF0000,0x0000FF00,0x000000FF);//多彩不变色(红）
      break;
    case 6:
      showImage16dots(0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000);//单色（红）
      break;
    default: 
      showImage();
      break;
  }
};

// Fill the dots one after the other with a color
void colorWipe(uint32_t c, uint8_t wait) {
  for(uint16_t i=0; i<strip.numPixels(); i++) {
      strip.setPixelColor(i, c);
      strip.show();
      delay(wait);
  }
}

void rainbow(uint8_t wait) {
  uint16_t i, j;

  for(j=0; j<256; j++) {
    for(i=0; i<strip.numPixels(); i++) {
      strip.setPixelColor(i, Wheel((10*i+j) & 255));
    }
    strip.show();
    delay(wait);
  }
}

// Slightly different, this makes the rainbow equally distributed throughout
void rainbowCycle(uint8_t wait) {
  uint16_t i, j;

  for(j=0; j<256*5; j++) { // 5 cycles of all colors on wheel
    for(i=0; i< strip.numPixels(); i++) {
      strip.setPixelColor(i, Wheel(((i * 256 / strip.numPixels()) + j) & 255));
    }
    strip.show();
    delay(wait);
  }
}

// Input a value 0 to 255 to get a color value.
// The colours are a transition r - g - b - back to r.
uint32_t Wheel(byte WheelPos) {
  if(WheelPos < 85) {
   return strip.Color(WheelPos * 3, 255 - WheelPos * 3, 0);
  } else if(WheelPos < 170) {
   WheelPos -= 85;
   return strip.Color(255 - WheelPos * 3, 0, WheelPos * 3);
  } else {
   WheelPos -= 170;
   return strip.Color(0, WheelPos * 3, 255 - WheelPos * 3);
  }
}


void showImage(){ 
  uint16_t temp;
  delay(65);
  for(int i=0 ; i<64 ; i++){
    temp = (tempImage[i*2+1]<<8)+tempImage[i*2];
    for(int j=0; j<16; j++){
        if(temp & 0x0001 == 0x0001){
          strip.setPixelColor(15-j,Wheel((((i * 256 / strip.numPixels()) + j + 80*flow)/8) & 255));
        }
        else
          strip.setPixelColor(15-j,0x00000000);
        temp = temp>>1;
    }
    strip.show(); 
    //delay(0.8);
  }
  for(int k=0; k<16; k++)
  strip.setPixelColor(k,0x00000000);
  strip.show();
  flow++;
} 


void showImage16dots(uint32_t color1, uint32_t color2, uint32_t color3, uint32_t color4) {
  uint16_t temp;
  delay(70);
  for (int i = 0 ; i < 64 ; i++) {
    temp = (tempImage[i * 2 + 1] << 8) + tempImage[i * 2];
    for (int j = 0; j < 16; j++) {
      if (temp & 0x01)
        switch(i/16){
          case 0 : strip.setPixelColor(15 - j, color1); break;
          case 1 : strip.setPixelColor(15 - j, color2); break;
          case 2 : strip.setPixelColor(15 - j, color3); break;
          case 3 : strip.setPixelColor(15 - j, color4); break;
        }
      else
        strip.setPixelColor(15 - j, 0);
      temp = temp >> 1;
    }
    strip.show();
  }
  for(int k=0; k<16; k++)
  strip.setPixelColor(k,0x00000000);
  strip.show();
}

void cpy(const uint8_t* imageArray){
  for(int i=0; i<128; i++)
  tempImage[i] =  pgm_read_byte_near(imageArray + i);
}





/*
void displayImage(){
  switch(count){
    case 0:
      showImage();//全彩渐变色（红）
      break;
    case 4: 
      showImage16dots(0x00FF00FF,0x00FF0000,0x0000FF00,0x000000FF);//多彩不变色（红）
      break;
    case 6:
      showImage16dots(0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000);//单色（红）
      break;
    default: 
      showImage();
      break;
  }
};
*/
  // put your main code here, to run repeatedly:
